# Algorithms-DataStructure
This repository includes algorithms and data structure textbooks, learning code   
### Chapter1 - Introduction to Algorithms
- **Binary Search**: 其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找**返回其位置**；否则返回null
- 对于包含n个元素的列表，二分查找最多需要log2n步，简单查找最多需要n步
- **仅当列表是有序的时候，二分查找才管用。**
- 二分查找的基线条件是数组只包含一个元素。如果要查找的值与这个元素相同，就找到了！否则，就说明它不在数组中。
在二分查找的递归条件中，你把数组分成两半，将其中一半丢弃，并对另一半执行二分查找。
### Chapter2 - Selection sort
  - Array and Linked list:
    - 链表的优点：链表的优势在插入元素方面
      1. 链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起
    - 链表的缺点：在需要读取链表的最后一个元素时，你不能直接读取，必须按顺序一个一个读过去
    - 数组的优点：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素
  - #### 总结：链表插入、删除快，读取慢（因为得一个一个读到最后一位索引）。数组插入、删除慢，读取快`
### Chapter3 - Recursive
- 递归只是让解决方案更清晰，并没有性能上的优势
- 每个递归函数都有两部分：**基线条件(base case)** 和 **递归条件(recursive case)**
- 调用栈(call stack) 只有两种操作 **压入** 和 **弹出**
  - 调用另一个函数时，当前函数暂停并处于未完成状态。新的函数会位于第一个内存块的上面，执行完，返回以后栈顶的内存块被弹出，再去调用函数体内的另一个函数，再压在当前函数的顶端。
  - 所有函数调用都进入调用栈
### Chapter4 - Quick sort
- Divide and Conquer分治策略
- **Quick sort 快速排序** - **平均运行时间为O(n log n)**
  - 基准值(pivot)
  - 分区(partitioning) 一个由所有小于基准值的数字组成的子数组 + 基准值 + 一个由所有大于基准值的数组组成的子数组
  - 基线条件：为空或只包含一个元素的数组是“有序”的
  - 递归条件：假设取数组的第一个元素为基准值
  - **分别递归调用quicksort来排序小于基准值的子数组，也排序大于基准值的总数组**
### Chapter5 - 散列表 Hash table 在python中实现为字典
- 结合使用`散列函数`和`数组`来创建散列表
- **缓存**的概念
  - 缓存的数据存储在散列表中
- **冲突**的概念：给两个键分配的位置相同
- Big-O：平均情况O(1) 最糟情况O(n)
### Chapter6 - Breadth-first search
- 最短路径问题(shortest-path problem) **解决最短路径问题的算法被称为广度优先搜索**
- 广度优先搜索是一种用于图的查找算法，可帮助回答两类问题：
  - 从节点A出发，有前往节点B的路径吗？
  - 从节点A出发，前往节点B的哪条路径最短？
  - **队列**的概念 队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队
- 实现图 图由多个节点组成 **使用散列表** 每个节点都与邻近节点相连，一种结构让你能够表示这种关
系
  - 将节点映射到其所有**邻居**
  - 键-值对的添加顺序重要吗？不重要 因为散列表是无序的
- **运行时间** 广度优先搜索的运行时间为O(人数 + 边数)，O(V + E)，其中V为顶点(vertice)数，E为边数
- **树** 树是一种特殊的图，其中没有往后指的边
### Chapter7 - 狄克斯特拉算法 (Dijkstra's algorithm)
**BFS算出来两个结果：有没有路径 和 最短路径，狄克斯特拉算法找出 最快路径**