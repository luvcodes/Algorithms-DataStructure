# Algorithms-DataStructure

This repository includes algorithms and data structure textbooks, learning code

### Chapter1 - Introduction to Algorithms

- **Binary Search**: 其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找**返回其位置**；否则返回null
- 对于包含n个元素的列表，二分查找最多需要log2n步，简单查找最多需要n步
- **仅当列表是有序的时候，二分查找才管用。**
- 二分查找的基线条件是数组只包含一个元素。如果要查找的值与这个元素相同，就找到了！否则，就说明它不在数组中。
在二分查找的递归条件中，你把数组分成两半，将其中一半丢弃，并对另一半执行二分查找。

### Chapter2 - Selection sort

- Array and Linked list:
  - 链表的优点：链表的优势在插入元素方面
      1. 链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起
  - 链表的缺点：在需要读取链表的最后一个元素时，你不能直接读取，必须按顺序一个一个读过去
  - 数组的优点：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素

- #### 总结：链表插入、删除快，读取慢（因为得一个一个读到最后一位索引）。数组插入、删除慢，读取快`

### Chapter3 - Recursive

- 递归只是让解决方案更清晰，并没有性能上的优势
- 每个递归函数都有两部分：**基线条件(base case)** 和 **递归条件(recursive case)**
- 调用栈(call stack) 只有两种操作 **压入** 和 **弹出**
  - 调用另一个函数时，当前函数暂停并处于未完成状态。新的函数会位于第一个内存块的上面，执行完，返回以后栈顶的内存块被弹出，再去调用函数体内的另一个函数，再压在当前函数的顶端。
  - 所有函数调用都进入调用栈

### Chapter4 - Quick sort

- Divide and Conquer分治策略
- **Quick sort 快速排序** - **平均运行时间为O(n log n)**
  - 基准值(pivot)
  - 分区(partitioning) 一个由所有小于基准值的数字组成的子数组 + 基准值 + 一个由所有大于基准值的数组组成的子数组
  - 基线条件：为空或只包含一个元素的数组是“有序”的
  - 递归条件：假设取数组的第一个元素为基准值
  - **分别递归调用quicksort来排序小于基准值的子数组，也排序大于基准值的总数组**

### Chapter5 - 散列表 Hash table 在python中实现为字典

- 结合使用`散列函数`和`数组`来创建散列表
- **缓存**的概念
  - 缓存的数据存储在散列表中
- **冲突**的概念：给两个键分配的位置相同
- Big-O：平均情况O(1) 最糟情况O(n)

### Chapter6 - Breadth-first search

- 最短路径问题(shortest-path problem) **解决最短路径问题的算法被称为广度优先搜索**
- 广度优先搜索是一种用于图的查找算法，可帮助回答两类问题：
  - 从节点A出发，有前往节点B的路径吗？
  - 从节点A出发，前往节点B的哪条路径最短？
  - **队列**的概念 队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队
- 实现图: 图由多个节点组成 **使用散列表** 每个节点都与邻近节点相连，一种结构让你能够表示这种关
  系
  - 将节点映射到其所有**邻居**
  - 键-值对的添加顺序重要吗？不重要 因为散列表是无序的
  - **有向图**和**无向图**
- **运行时间** 广度优先搜索的运行时间为O(人数 + 边数)，O(V + E)，其中V为顶点(vertice)数，E为边数

### Chapter7 - 狄克斯特拉算法 (Dijkstra's algorithm)

**BFS算出来两个结果：有没有路径 和 最短路径，狄克斯特拉算法找出 最快路径**

- 4个步骤
  1. 找出可在最短时间内到达的节点
  2. 更新该节点的邻居的开销
  3. 重复过程，知道对图中的每个节点都这样做了
  4. 计算最终路径
- 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为**权重（weight）**
- 广度优先搜索用于在非加权图中查找最短路径。狄克斯特拉算法用于在加权图中查找最短路径。
**狄克斯特拉算法只适用于有向无环图(directed acyclic graph，DAG)**
**如果有负权边，就不能使用狄克斯特拉算法**

### Chapter8 Greedy algorithm 贪心算法

- 贪心算法
- 近似算法
- 集合set的概念：集合类似于列表，只是同样的元素只能出现一次，**集合不能包含重复的元素**
- **旅行商问题和集合覆盖问题共同之处：需要计算所有的解，并从中选出最小/最短的那个** 都是 **NP完全问题**
- **判断问题是不是NP完全问题，如果是直接使用近似算法(找出符合要求最多的 + 不断重复这个过程直到满足要求)**
- **贪婪算法易于实现、运行速度快，是不错的近似算法**

### Chapter9 动态规划

- 使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分。
- 但使用贪婪算法可轻松地处理这种情况，尽可能多地拿价值最高的商品
- 动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题，但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。
- 找出最长公共子串

### Chapter10 K临近算法

- 使用KNN来做两项基本工作——分类和回归
- KNN用于分类和回归，需要考虑最近的邻居
- 分类就是编组
- 回归就是预测结果（如数字）
- 特征抽取

### 基于《啊哈！算法》的阅读 以此来记录笔记

#### Chapter 1 排序


### 基于《大话数据结构》阅读 来记录学习笔记

#### 第一章 数据结构绪论

##### 1.5 逻辑结构与物理结构

- 逻辑结构
  - 集合结构: 数据元素除了同属于一个集合外，没有其他关系。
  - 线性结构: 数据元素是一对一的关系
  - 树形结构: 数据元素之间存在一种一对多的关系
  - 图形结构: 数据元素师多对多的关系

- 物理结构

  - 顺序存储: 数据元素存放在地址连续的存储单元里。
  - 链式存储: 数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

#### 第二章 算法

##### 2.8 函数的渐进增长

- 输入规模n在没有限制的情况下，只要超过一个数值N，这个函数就总是大于另一个函数，我们称函数是渐进增长的。
- 定义: 给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n > N, fn总是比gn大，那么我们就说fn的增长渐进快于gn

1. 最高次项相乘的常数并不重要
2. 最高次项的指数大的，函数随着n的增长，结果也会变的增长特别快。
3. 判断一个算法的效率时，函数中的常数和其它次要项常常可以忽略，而更应该关注主项(最高次项)的阶数。

- **算法时间复杂度**: 一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。n代表问题规模，T(n)代表语句总的执行次数。
  - 推导大O阶方法:
      1. 用常数1取代运行实践中的所有加法常数
      2. 在修改后的运行次数函数中，只保留最高阶项
      3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。
      4. ![](/Users/yangrunze/Library/Application Support/typora-user-images/截屏2023-07-31 上午12.10.05.png)

#### 第三章 线性表

##### 3.2 线性表的定义

- 线性表(List): 零个或多个数据元素的有限序列
  - 元素之间是有顺序的
  - 线性表强调是有限的
  - 元素的数据类型相同

##### 线性表的两种物理结构

- 顺序存储结构: **一维数组**
- 链式存储结构: 

##### 3.4 线性表的顺序结构

- 顺序存储: 用一段地址连续的存储单元依次存储线性表的数据元素。
  - 描述顺序存储结构需要三个属性
    - 存储空间的起始位置
    - 线性表的最大存储容量: 数组长度MaxSize
    - 线性表的当前长度: length
  - 区分数组长度MaxSize和线性表长度length
    - 数组长度是存放线性表的存储空间的长度，**存储分配后这个量一般是不变的**。
    - 线性表的长度是线性表中数据元素的个数，这个量是变化的。
    - 在任一时刻，线性表的长度应该小于等于数组的长度。用数组存储顺序表意味着分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于档案线性表的长度。

##### 3.5 线性表顺序存储结构的插入与删除

- 顺序存储结构的优势就在于它的读和存的效率很高，但是插入和删除效率很低，因为每次插入和删除都需要移动大量的元素。
  - 为什么每次插入和删除都需要移动大量的元素呢？
    - 因为相邻两个元素的存储位置也有邻居关系(内存地址相邻)

- 插入算法的思路: 
  - 如果插入位置不合理，抛出异常
  - 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
  - 从最后一个元素向前遍历到第i个位置，分别将它们都向后移动一个位置
  - 将要插入元素填入位置i处
  - 表长 + 1

- 删除算法的思路: 
  - 如果删除位置不合理，抛出异常
  - 取出删除元素
  - 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
  - 表长 - 1


##### 3.6 线性表的链式存储结构

- 单链表不定义表长
- 顺序存储结构不够好的原因，其实也就是为什么链式存储结构更好? 
  - 顺序存储结构的添加和删除效率很低，这就是因为在内存地址中的位置也都是相邻的，导致每一次添加或者删除元素都需要移动大量元素。
- 数据域和指针域
  - **数据域**: 存储数据元素信息的域称为数据域
  - **指针域**: 存储后继位置的域叫做指针域，其中存储的信息叫做指针或链
- 数据域和指针域合在一起的元素ai的存储映像，称为**结点**
- 头指针与头节点的区分
  - 头指针是: 链表中第一个节点的**存储位置**，也就是说它是一个地址。头指针是链表的必要元素。头指针是指链表指向第一个结点的指针，如果链表有头结点，则是指向头节点的指针。
  - 头结点: 链表中第一个节点的前面再设置一个节点，叫做头结点。头结点的指针域存储着指向第一个节点的指针。头结点不一定是链表的必要元素。头结点的指针域存储指向第一个结点的指针。
  - 见书`3-6-8`图

##### 3.7 单链表的读取

- 获得链表第i个数据的算法思路
  - 从头往后找，找到第i个元素

##### 3.8 单链表的插入与删除

- 单链表第i个数据插入结点的算法思路: 见书的page 62
- 单链表的删除: 见书的page 64

##### 3.12 静态链表

- 概念: 用数组描述的链表叫做静态链表。静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。
- 用数组来代替指针，来描述单链表
  - 让数组的元素都是由两个数据域组成,data和cur
- 静态链表的插入操作
- 静态链表的删除操作

##### 3.13 循环链表

- 循环链表解决了一个很麻烦的问题: 如何从当中一个结点出发，访问到链表的全部结点。

##### 3.14 双向链表

#### 第四章 栈与队列

##### 4.2 栈的定义

- 栈(stack)是限定在表尾进行插入和删除操作的线性表。这个表尾 实际就是允许插入和删除的一端，叫做栈顶(top), 另一侧叫做栈底。**后进先出**的线性表
- 栈底是固定的，最先进栈的只能在栈底

##### 4.3 栈的抽象数据类型

##### 4.4 栈的顺序存储结构及实现

##### 4.5 两栈共享空间

##### 4.6 栈的链式存储结构实现

- 对比链栈和顺序栈
  - 时间复杂度 = O(1), 不涉及任何循环
  - 顺序栈需要事先确定一个固定的长度，有可能会造成内存资源空间浪费的问题，优势是存储时定位很方便
  - 链栈要求每个元素都有指针域，增加了一些内存开销，但对于栈的长度无限制。

