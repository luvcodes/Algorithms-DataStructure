# Algorithms-DataStructure

This repository includes algorithms and data structure textbooks, learning code

### Chapter1 - Introduction to Algorithms

- **Binary Search**: 其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找**返回其位置**；否则返回null
- 对于包含n个元素的列表，二分查找最多需要log2n步，简单查找最多需要n步
- **仅当列表是有序的时候，二分查找才管用。**
- 二分查找的基线条件是数组只包含一个元素。如果要查找的值与这个元素相同，就找到了！否则，就说明它不在数组中。
在二分查找的递归条件中，你把数组分成两半，将其中一半丢弃，并对另一半执行二分查找。

### Chapter2 - Selection sort

- Array and Linked list:
  - 链表的优点：链表的优势在插入元素方面
      1. 链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起
  - 链表的缺点：在需要读取链表的最后一个元素时，你不能直接读取，必须按顺序一个一个读过去
  - 数组的优点：需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素

- #### 总结：链表插入、删除快，读取慢（因为得一个一个读到最后一位索引）。数组插入、删除慢，读取快`

### Chapter3 - Recursive

- 递归只是让解决方案更清晰，并没有性能上的优势
- 每个递归函数都有两部分：**基线条件(base case)** 和 **递归条件(recursive case)**
- 调用栈(call stack) 只有两种操作 **压入** 和 **弹出**
  - 调用另一个函数时，当前函数暂停并处于未完成状态。新的函数会位于第一个内存块的上面，执行完，返回以后栈顶的内存块被弹出，再去调用函数体内的另一个函数，再压在当前函数的顶端。
  - 所有函数调用都进入调用栈

### Chapter4 - Quick sort

- Divide and Conquer分治策略
- **Quick sort 快速排序** - **平均运行时间为O(n log n)**
  - 基准值(pivot)
  - 分区(partitioning) 一个由所有小于基准值的数字组成的子数组 + 基准值 + 一个由所有大于基准值的数组组成的子数组
  - 基线条件：为空或只包含一个元素的数组是“有序”的
  - 递归条件：假设取数组的第一个元素为基准值
  - **分别递归调用quicksort来排序小于基准值的子数组，也排序大于基准值的总数组**

### Chapter5 - 散列表 Hash table 在python中实现为字典

- 结合使用`散列函数`和`数组`来创建散列表
- **缓存**的概念
  - 缓存的数据存储在散列表中
- **冲突**的概念：给两个键分配的位置相同
- Big-O：平均情况O(1) 最糟情况O(n)

### Chapter6 - Breadth-first search

- 最短路径问题(shortest-path problem) **解决最短路径问题的算法被称为广度优先搜索**
- 广度优先搜索是一种用于图的查找算法，可帮助回答两类问题：
  - 从节点A出发，有前往节点B的路径吗？
  - 从节点A出发，前往节点B的哪条路径最短？
  - **队列**的概念 队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队
- 实现图: 图由多个节点组成 **使用散列表** 每个节点都与邻近节点相连，一种结构让你能够表示这种关
  系
  - 将节点映射到其所有**邻居**
  - 键-值对的添加顺序重要吗？不重要 因为散列表是无序的
  - **有向图**和**无向图**
- **运行时间** 广度优先搜索的运行时间为O(人数 + 边数)，O(V + E)，其中V为顶点(vertice)数，E为边数

### Chapter7 - 狄克斯特拉算法 (Dijkstra's algorithm)

**BFS算出来两个结果：有没有路径 和 最短路径，狄克斯特拉算法找出 最快路径**

- 4个步骤
  1. 找出可在最短时间内到达的节点
  2. 更新该节点的邻居的开销
  3. 重复过程，知道对图中的每个节点都这样做了
  4. 计算最终路径
- 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为**权重（weight）**
- 广度优先搜索用于在非加权图中查找最短路径。狄克斯特拉算法用于在加权图中查找最短路径。
**狄克斯特拉算法只适用于有向无环图(directed acyclic graph，DAG)**
**如果有负权边，就不能使用狄克斯特拉算法**

### Chapter8 Greedy algorithm 贪心算法

- 贪心算法
- 近似算法
- 集合set的概念：集合类似于列表，只是同样的元素只能出现一次，**集合不能包含重复的元素**
- **旅行商问题和集合覆盖问题共同之处：需要计算所有的解，并从中选出最小/最短的那个** 都是 **NP完全问题**
- **判断问题是不是NP完全问题，如果是直接使用近似算法(找出符合要求最多的 + 不断重复这个过程直到满足要求)**
- **贪婪算法易于实现、运行速度快，是不错的近似算法**

### Chapter9 动态规划

- 使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分。
- 但使用贪婪算法可轻松地处理这种情况，尽可能多地拿价值最高的商品
- 动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题，但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。
- 找出最长公共子串